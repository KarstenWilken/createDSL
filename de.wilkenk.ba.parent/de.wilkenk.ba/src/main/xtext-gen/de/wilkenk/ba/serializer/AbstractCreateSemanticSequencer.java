/*
 * generated by Xtext 2.10.0
 */
package de.wilkenk.ba.serializer;

import com.google.inject.Inject;
import de.wilkenk.ba.create.AddCombination;
import de.wilkenk.ba.create.Addition;
import de.wilkenk.ba.create.Attribute;
import de.wilkenk.ba.create.AttributeRaise;
import de.wilkenk.ba.create.AttributeRef;
import de.wilkenk.ba.create.Category;
import de.wilkenk.ba.create.Combination;
import de.wilkenk.ba.create.CombinationCondition;
import de.wilkenk.ba.create.CombinationRaise;
import de.wilkenk.ba.create.CombinationRef;
import de.wilkenk.ba.create.CombinedAttribute;
import de.wilkenk.ba.create.CombinedAttributeRef;
import de.wilkenk.ba.create.Condition;
import de.wilkenk.ba.create.Consequence;
import de.wilkenk.ba.create.ConstantBasedRaise;
import de.wilkenk.ba.create.CreatePackage;
import de.wilkenk.ba.create.DecisionTable;
import de.wilkenk.ba.create.DecisionTableRef;
import de.wilkenk.ba.create.DeleteCombination;
import de.wilkenk.ba.create.Dice;
import de.wilkenk.ba.create.DiceBasedRaise;
import de.wilkenk.ba.create.DiceRef;
import de.wilkenk.ba.create.Domainmodel;
import de.wilkenk.ba.create.InitAttribute;
import de.wilkenk.ba.create.InitialAttributeDecision;
import de.wilkenk.ba.create.Multiplication;
import de.wilkenk.ba.create.Operation;
import de.wilkenk.ba.create.Property;
import de.wilkenk.ba.create.Row;
import de.wilkenk.ba.create.RowRef;
import de.wilkenk.ba.services.CreateGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;
import org.eclipse.xtext.common.types.JvmInnerTypeReference;
import org.eclipse.xtext.common.types.JvmLowerBound;
import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;
import org.eclipse.xtext.common.types.JvmTypeParameter;
import org.eclipse.xtext.common.types.JvmUpperBound;
import org.eclipse.xtext.common.types.JvmWildcardTypeReference;
import org.eclipse.xtext.common.types.TypesPackage;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.eclipse.xtext.xbase.XAssignment;
import org.eclipse.xtext.xbase.XBasicForLoopExpression;
import org.eclipse.xtext.xbase.XBinaryOperation;
import org.eclipse.xtext.xbase.XBlockExpression;
import org.eclipse.xtext.xbase.XBooleanLiteral;
import org.eclipse.xtext.xbase.XCasePart;
import org.eclipse.xtext.xbase.XCastedExpression;
import org.eclipse.xtext.xbase.XCatchClause;
import org.eclipse.xtext.xbase.XClosure;
import org.eclipse.xtext.xbase.XConstructorCall;
import org.eclipse.xtext.xbase.XDoWhileExpression;
import org.eclipse.xtext.xbase.XFeatureCall;
import org.eclipse.xtext.xbase.XForLoopExpression;
import org.eclipse.xtext.xbase.XIfExpression;
import org.eclipse.xtext.xbase.XInstanceOfExpression;
import org.eclipse.xtext.xbase.XListLiteral;
import org.eclipse.xtext.xbase.XMemberFeatureCall;
import org.eclipse.xtext.xbase.XNullLiteral;
import org.eclipse.xtext.xbase.XNumberLiteral;
import org.eclipse.xtext.xbase.XPostfixOperation;
import org.eclipse.xtext.xbase.XReturnExpression;
import org.eclipse.xtext.xbase.XSetLiteral;
import org.eclipse.xtext.xbase.XStringLiteral;
import org.eclipse.xtext.xbase.XSwitchExpression;
import org.eclipse.xtext.xbase.XSynchronizedExpression;
import org.eclipse.xtext.xbase.XThrowExpression;
import org.eclipse.xtext.xbase.XTryCatchFinallyExpression;
import org.eclipse.xtext.xbase.XTypeLiteral;
import org.eclipse.xtext.xbase.XUnaryOperation;
import org.eclipse.xtext.xbase.XVariableDeclaration;
import org.eclipse.xtext.xbase.XWhileExpression;
import org.eclipse.xtext.xbase.XbasePackage;
import org.eclipse.xtext.xbase.serializer.XbaseSemanticSequencer;
import org.eclipse.xtext.xtype.XFunctionTypeRef;
import org.eclipse.xtext.xtype.XImportDeclaration;
import org.eclipse.xtext.xtype.XImportSection;
import org.eclipse.xtext.xtype.XtypePackage;

@SuppressWarnings("all")
public abstract class AbstractCreateSemanticSequencer extends XbaseSemanticSequencer {

	@Inject
	private CreateGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CreatePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CreatePackage.ADD_COMBINATION:
				sequence_AddCombination(context, (AddCombination) semanticObject); 
				return; 
			case CreatePackage.ADDITION:
				sequence_Addition(context, (Addition) semanticObject); 
				return; 
			case CreatePackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case CreatePackage.ATTRIBUTE_RAISE:
				sequence_AttributeRaise(context, (AttributeRaise) semanticObject); 
				return; 
			case CreatePackage.ATTRIBUTE_REF:
				sequence_AttributeRef(context, (AttributeRef) semanticObject); 
				return; 
			case CreatePackage.CATEGORY:
				sequence_Category(context, (Category) semanticObject); 
				return; 
			case CreatePackage.CHARACTER:
				sequence_Character(context, (de.wilkenk.ba.create.Character) semanticObject); 
				return; 
			case CreatePackage.COMBINATION:
				sequence_Combination(context, (Combination) semanticObject); 
				return; 
			case CreatePackage.COMBINATION_CONDITION:
				sequence_CombinationCondition(context, (CombinationCondition) semanticObject); 
				return; 
			case CreatePackage.COMBINATION_RAISE:
				sequence_CombinationRaise(context, (CombinationRaise) semanticObject); 
				return; 
			case CreatePackage.COMBINATION_REF:
				sequence_CombinationRef(context, (CombinationRef) semanticObject); 
				return; 
			case CreatePackage.COMBINED_ATTRIBUTE:
				sequence_CombinedAttribute(context, (CombinedAttribute) semanticObject); 
				return; 
			case CreatePackage.COMBINED_ATTRIBUTE_REF:
				sequence_CombinedAttributeRef(context, (CombinedAttributeRef) semanticObject); 
				return; 
			case CreatePackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case CreatePackage.CONSEQUENCE:
				sequence_Consequence(context, (Consequence) semanticObject); 
				return; 
			case CreatePackage.CONSTANT_BASED_RAISE:
				sequence_ConstantBasedRaise(context, (ConstantBasedRaise) semanticObject); 
				return; 
			case CreatePackage.DECISION_TABLE:
				sequence_DecisionTable(context, (DecisionTable) semanticObject); 
				return; 
			case CreatePackage.DECISION_TABLE_REF:
				sequence_DecisionTableRef(context, (DecisionTableRef) semanticObject); 
				return; 
			case CreatePackage.DELETE_COMBINATION:
				sequence_DeleteCombination(context, (DeleteCombination) semanticObject); 
				return; 
			case CreatePackage.DICE:
				sequence_Dice(context, (Dice) semanticObject); 
				return; 
			case CreatePackage.DICE_BASED_RAISE:
				sequence_DiceBasedRaise(context, (DiceBasedRaise) semanticObject); 
				return; 
			case CreatePackage.DICE_REF:
				sequence_DiceRef(context, (DiceRef) semanticObject); 
				return; 
			case CreatePackage.DOMAINMODEL:
				sequence_Domainmodel(context, (Domainmodel) semanticObject); 
				return; 
			case CreatePackage.INIT_ATTRIBUTE:
				sequence_InitAttribute(context, (InitAttribute) semanticObject); 
				return; 
			case CreatePackage.INITIAL_ATTRIBUTE_DECISION:
				sequence_InitialAttributeDecision(context, (InitialAttributeDecision) semanticObject); 
				return; 
			case CreatePackage.MULTIPLICATION:
				sequence_Multiplication(context, (Multiplication) semanticObject); 
				return; 
			case CreatePackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case CreatePackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case CreatePackage.ROW:
				sequence_Row(context, (Row) semanticObject); 
				return; 
			case CreatePackage.ROW_REF:
				sequence_RowRef(context, (RowRef) semanticObject); 
				return; 
			}
		else if (epackage == TypesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TypesPackage.JVM_FORMAL_PARAMETER:
				if (rule == grammarAccess.getFullJvmFormalParameterRule()) {
					sequence_FullJvmFormalParameter(context, (JvmFormalParameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmFormalParameterRule()) {
					sequence_JvmFormalParameter(context, (JvmFormalParameter) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_GENERIC_ARRAY_TYPE_REFERENCE:
				sequence_JvmTypeReference(context, (JvmGenericArrayTypeReference) semanticObject); 
				return; 
			case TypesPackage.JVM_INNER_TYPE_REFERENCE:
				sequence_JvmParameterizedTypeReference(context, (JvmInnerTypeReference) semanticObject); 
				return; 
			case TypesPackage.JVM_LOWER_BOUND:
				if (rule == grammarAccess.getJvmLowerBoundAndedRule()) {
					sequence_JvmLowerBoundAnded(context, (JvmLowerBound) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmLowerBoundRule()) {
					sequence_JvmLowerBound(context, (JvmLowerBound) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_PARAMETERIZED_TYPE_REFERENCE:
				if (action == grammarAccess.getJvmParameterizedTypeReferenceAccess().getJvmInnerTypeReferenceOuterAction_1_4_0_0_0()) {
					sequence_JvmParameterizedTypeReference_JvmInnerTypeReference_1_4_0_0_0(context, (JvmParameterizedTypeReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmTypeReferenceRule()
						|| action == grammarAccess.getJvmTypeReferenceAccess().getJvmGenericArrayTypeReferenceComponentTypeAction_0_1_0_0()
						|| rule == grammarAccess.getJvmParameterizedTypeReferenceRule()
						|| rule == grammarAccess.getJvmArgumentTypeReferenceRule()) {
					sequence_JvmParameterizedTypeReference(context, (JvmParameterizedTypeReference) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_TYPE_PARAMETER:
				sequence_JvmTypeParameter(context, (JvmTypeParameter) semanticObject); 
				return; 
			case TypesPackage.JVM_UPPER_BOUND:
				if (rule == grammarAccess.getJvmUpperBoundAndedRule()) {
					sequence_JvmUpperBoundAnded(context, (JvmUpperBound) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmUpperBoundRule()) {
					sequence_JvmUpperBound(context, (JvmUpperBound) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_WILDCARD_TYPE_REFERENCE:
				sequence_JvmWildcardTypeReference(context, (JvmWildcardTypeReference) semanticObject); 
				return; 
			}
		else if (epackage == XbasePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XbasePackage.XASSIGNMENT:
				sequence_XAssignment_XMemberFeatureCall(context, (XAssignment) semanticObject); 
				return; 
			case XbasePackage.XBASIC_FOR_LOOP_EXPRESSION:
				sequence_XBasicForLoopExpression(context, (XBasicForLoopExpression) semanticObject); 
				return; 
			case XbasePackage.XBINARY_OPERATION:
				sequence_XAdditiveExpression_XAndExpression_XAssignment_XEqualityExpression_XMultiplicativeExpression_XOrExpression_XOtherOperatorExpression_XRelationalExpression(context, (XBinaryOperation) semanticObject); 
				return; 
			case XbasePackage.XBLOCK_EXPRESSION:
				if (rule == grammarAccess.getXExpressionRule()
						|| rule == grammarAccess.getXAssignmentRule()
						|| action == grammarAccess.getXAssignmentAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOrExpressionRule()
						|| action == grammarAccess.getXOrExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAndExpressionRule()
						|| action == grammarAccess.getXAndExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXEqualityExpressionRule()
						|| action == grammarAccess.getXEqualityExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXRelationalExpressionRule()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOtherOperatorExpressionRule()
						|| action == grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAdditiveExpressionRule()
						|| action == grammarAccess.getXAdditiveExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXMultiplicativeExpressionRule()
						|| action == grammarAccess.getXMultiplicativeExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXUnaryOperationRule()
						|| rule == grammarAccess.getXCastedExpressionRule()
						|| action == grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0()
						|| rule == grammarAccess.getXPostfixOperationRule()
						|| action == grammarAccess.getXPostfixOperationAccess().getXPostfixOperationOperandAction_1_0_0()
						|| rule == grammarAccess.getXMemberFeatureCallRule()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXAssignmentAssignableAction_1_0_0_0_0()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXMemberFeatureCallMemberCallTargetAction_1_1_0_0_0()
						|| rule == grammarAccess.getXPrimaryExpressionRule()
						|| rule == grammarAccess.getXParenthesizedExpressionRule()
						|| rule == grammarAccess.getXBlockExpressionRule()
						|| rule == grammarAccess.getXExpressionOrVarDeclarationRule()) {
					sequence_XBlockExpression(context, (XBlockExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getXExpressionInClosureRule()) {
					sequence_XExpressionInClosure(context, (XBlockExpression) semanticObject); 
					return; 
				}
				else break;
			case XbasePackage.XBOOLEAN_LITERAL:
				sequence_XBooleanLiteral(context, (XBooleanLiteral) semanticObject); 
				return; 
			case XbasePackage.XCASE_PART:
				sequence_XCasePart(context, (XCasePart) semanticObject); 
				return; 
			case XbasePackage.XCASTED_EXPRESSION:
				sequence_XCastedExpression(context, (XCastedExpression) semanticObject); 
				return; 
			case XbasePackage.XCATCH_CLAUSE:
				sequence_XCatchClause(context, (XCatchClause) semanticObject); 
				return; 
			case XbasePackage.XCLOSURE:
				if (rule == grammarAccess.getXExpressionRule()
						|| rule == grammarAccess.getXAssignmentRule()
						|| action == grammarAccess.getXAssignmentAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOrExpressionRule()
						|| action == grammarAccess.getXOrExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAndExpressionRule()
						|| action == grammarAccess.getXAndExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXEqualityExpressionRule()
						|| action == grammarAccess.getXEqualityExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXRelationalExpressionRule()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOtherOperatorExpressionRule()
						|| action == grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAdditiveExpressionRule()
						|| action == grammarAccess.getXAdditiveExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXMultiplicativeExpressionRule()
						|| action == grammarAccess.getXMultiplicativeExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXUnaryOperationRule()
						|| rule == grammarAccess.getXCastedExpressionRule()
						|| action == grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0()
						|| rule == grammarAccess.getXPostfixOperationRule()
						|| action == grammarAccess.getXPostfixOperationAccess().getXPostfixOperationOperandAction_1_0_0()
						|| rule == grammarAccess.getXMemberFeatureCallRule()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXAssignmentAssignableAction_1_0_0_0_0()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXMemberFeatureCallMemberCallTargetAction_1_1_0_0_0()
						|| rule == grammarAccess.getXPrimaryExpressionRule()
						|| rule == grammarAccess.getXLiteralRule()
						|| rule == grammarAccess.getXClosureRule()
						|| rule == grammarAccess.getXParenthesizedExpressionRule()
						|| rule == grammarAccess.getXExpressionOrVarDeclarationRule()) {
					sequence_XClosure(context, (XClosure) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getXShortClosureRule()) {
					sequence_XShortClosure(context, (XClosure) semanticObject); 
					return; 
				}
				else break;
			case XbasePackage.XCONSTRUCTOR_CALL:
				sequence_XConstructorCall(context, (XConstructorCall) semanticObject); 
				return; 
			case XbasePackage.XDO_WHILE_EXPRESSION:
				sequence_XDoWhileExpression(context, (XDoWhileExpression) semanticObject); 
				return; 
			case XbasePackage.XFEATURE_CALL:
				sequence_XFeatureCall(context, (XFeatureCall) semanticObject); 
				return; 
			case XbasePackage.XFOR_LOOP_EXPRESSION:
				sequence_XForLoopExpression(context, (XForLoopExpression) semanticObject); 
				return; 
			case XbasePackage.XIF_EXPRESSION:
				sequence_XIfExpression(context, (XIfExpression) semanticObject); 
				return; 
			case XbasePackage.XINSTANCE_OF_EXPRESSION:
				sequence_XRelationalExpression(context, (XInstanceOfExpression) semanticObject); 
				return; 
			case XbasePackage.XLIST_LITERAL:
				sequence_XListLiteral(context, (XListLiteral) semanticObject); 
				return; 
			case XbasePackage.XMEMBER_FEATURE_CALL:
				sequence_XMemberFeatureCall(context, (XMemberFeatureCall) semanticObject); 
				return; 
			case XbasePackage.XNULL_LITERAL:
				sequence_XNullLiteral(context, (XNullLiteral) semanticObject); 
				return; 
			case XbasePackage.XNUMBER_LITERAL:
				sequence_XNumberLiteral(context, (XNumberLiteral) semanticObject); 
				return; 
			case XbasePackage.XPOSTFIX_OPERATION:
				sequence_XPostfixOperation(context, (XPostfixOperation) semanticObject); 
				return; 
			case XbasePackage.XRETURN_EXPRESSION:
				sequence_XReturnExpression(context, (XReturnExpression) semanticObject); 
				return; 
			case XbasePackage.XSET_LITERAL:
				sequence_XSetLiteral(context, (XSetLiteral) semanticObject); 
				return; 
			case XbasePackage.XSTRING_LITERAL:
				sequence_XStringLiteral(context, (XStringLiteral) semanticObject); 
				return; 
			case XbasePackage.XSWITCH_EXPRESSION:
				sequence_XSwitchExpression(context, (XSwitchExpression) semanticObject); 
				return; 
			case XbasePackage.XSYNCHRONIZED_EXPRESSION:
				sequence_XSynchronizedExpression(context, (XSynchronizedExpression) semanticObject); 
				return; 
			case XbasePackage.XTHROW_EXPRESSION:
				sequence_XThrowExpression(context, (XThrowExpression) semanticObject); 
				return; 
			case XbasePackage.XTRY_CATCH_FINALLY_EXPRESSION:
				sequence_XTryCatchFinallyExpression(context, (XTryCatchFinallyExpression) semanticObject); 
				return; 
			case XbasePackage.XTYPE_LITERAL:
				sequence_XTypeLiteral(context, (XTypeLiteral) semanticObject); 
				return; 
			case XbasePackage.XUNARY_OPERATION:
				sequence_XUnaryOperation(context, (XUnaryOperation) semanticObject); 
				return; 
			case XbasePackage.XVARIABLE_DECLARATION:
				sequence_XVariableDeclaration(context, (XVariableDeclaration) semanticObject); 
				return; 
			case XbasePackage.XWHILE_EXPRESSION:
				sequence_XWhileExpression(context, (XWhileExpression) semanticObject); 
				return; 
			}
		else if (epackage == XtypePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XtypePackage.XFUNCTION_TYPE_REF:
				sequence_XFunctionTypeRef(context, (XFunctionTypeRef) semanticObject); 
				return; 
			case XtypePackage.XIMPORT_DECLARATION:
				sequence_XImportDeclaration(context, (XImportDeclaration) semanticObject); 
				return; 
			case XtypePackage.XIMPORT_SECTION:
				sequence_XImportSection(context, (XImportSection) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     CombinationRaiseType returns AddCombination
	 *     AddCombination returns AddCombination
	 *
	 * Constraint:
	 *     add=Combination
	 */
	protected void sequence_AddCombination(ISerializationContext context, AddCombination semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.ADD_COMBINATION__ADD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.ADD_COMBINATION__ADD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddCombinationAccess().getAddCombinationParserRuleCall_1_0(), semanticObject.getAdd());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MathExpression returns Addition
	 *     Addition returns Addition
	 *     Addition.Addition_1_0 returns Addition
	 *     Multiplication returns Addition
	 *     Multiplication.Multiplication_1_0 returns Addition
	 *     Primary returns Addition
	 *
	 * Constraint:
	 *     (left=Addition_Addition_1_0 (op='+' | op='-') right=Multiplication)
	 */
	protected void sequence_Addition(ISerializationContext context, Addition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns AttributeRaise
	 *     Raise returns AttributeRaise
	 *     AttributeRaise returns AttributeRaise
	 *
	 * Constraint:
	 *     (name=ValidID target=[Attribute|ID] tries=INT? valueChange=AttributeRaiseType)
	 */
	protected void sequence_AttributeRaise(ISerializationContext context, AttributeRaise semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeRef returns AttributeRef
	 *     MathExpression returns AttributeRef
	 *     Addition returns AttributeRef
	 *     Addition.Addition_1_0 returns AttributeRef
	 *     Multiplication returns AttributeRef
	 *     Multiplication.Multiplication_1_0 returns AttributeRef
	 *     Primary returns AttributeRef
	 *     ConditionTargets returns AttributeRef
	 *
	 * Constraint:
	 *     (attribute=[Attribute|ID] part=AttributePart)
	 */
	protected void sequence_AttributeRef(ISerializationContext context, AttributeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.ATTRIBUTE_REF__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.ATTRIBUTE_REF__ATTRIBUTE));
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.ATTRIBUTE_REF__PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.ATTRIBUTE_REF__PART));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeRefAccess().getAttributeAttributeIDTerminalRuleCall_0_0_1(), semanticObject.getAttribute());
		feeder.accept(grammarAccess.getAttributeRefAccess().getPartAttributePartEnumRuleCall_2_0(), semanticObject.getPart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Attribute
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (
	 *         name=QualifiedName 
	 *         (minValue=INT maxValue=INT)? 
	 *         value=INT? 
	 *         initialValue=InitialAttributeDecision? 
	 *         category=[Category|ID]? 
	 *         description=ID?
	 *     )
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Category
	 *     Category returns Category
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Category(ISerializationContext context, Category semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.ENTITY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.ENTITY__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCategoryAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Character
	 *     Character returns Character
	 *
	 * Constraint:
	 *     (name=QualifiedName properties+=Property* operations+=Operation*)
	 */
	protected void sequence_Character(ISerializationContext context, de.wilkenk.ba.create.Character semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CombinationCondition returns CombinationCondition
	 *
	 * Constraint:
	 *     (name=ID condition=XExpression)
	 */
	protected void sequence_CombinationCondition(ISerializationContext context, CombinationCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.COMBINATION_CONDITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.COMBINATION_CONDITION__NAME));
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.COMBINATION_CONDITION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.COMBINATION_CONDITION__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCombinationConditionAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCombinationConditionAccess().getConditionXExpressionParserRuleCall_3_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns CombinationRaise
	 *     Raise returns CombinationRaise
	 *     CombinationRaise returns CombinationRaise
	 *
	 * Constraint:
	 *     (name=ValidID actions+=CombinationRaiseType+)
	 */
	protected void sequence_CombinationRaise(ISerializationContext context, CombinationRaise semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CombinationRef returns CombinationRef
	 *     ConditionTargets returns CombinationRef
	 *
	 * Constraint:
	 *     (combination=[Combination|ID] part=CombinationPart)
	 */
	protected void sequence_CombinationRef(ISerializationContext context, CombinationRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.COMBINATION_REF__COMBINATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.COMBINATION_REF__COMBINATION));
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.COMBINATION_REF__PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.COMBINATION_REF__PART));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCombinationRefAccess().getCombinationCombinationIDTerminalRuleCall_0_0_1(), semanticObject.getCombination());
		feeder.accept(grammarAccess.getCombinationRefAccess().getPartCombinationPartEnumRuleCall_2_0(), semanticObject.getPart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Combination
	 *     Combination returns Combination
	 *
	 * Constraint:
	 *     (name=ID conditions+=CombinationCondition* raise=[Raise|ID])
	 */
	protected void sequence_Combination(ISerializationContext context, Combination semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CombinedAttributeRef returns CombinedAttributeRef
	 *     ConditionTargets returns CombinedAttributeRef
	 *
	 * Constraint:
	 *     (combinedAttribute=[CombinedAttribute|ID] part=CombinedAttributePart)
	 */
	protected void sequence_CombinedAttributeRef(ISerializationContext context, CombinedAttributeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.COMBINED_ATTRIBUTE_REF__COMBINED_ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.COMBINED_ATTRIBUTE_REF__COMBINED_ATTRIBUTE));
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.COMBINED_ATTRIBUTE_REF__PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.COMBINED_ATTRIBUTE_REF__PART));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCombinedAttributeRefAccess().getCombinedAttributeCombinedAttributeIDTerminalRuleCall_0_0_1(), semanticObject.getCombinedAttribute());
		feeder.accept(grammarAccess.getCombinedAttributeRefAccess().getPartCombinedAttributePartEnumRuleCall_2_0(), semanticObject.getPart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns CombinedAttribute
	 *     CombinedAttribute returns CombinedAttribute
	 *
	 * Constraint:
	 *     (
	 *         name=QualifiedName 
	 *         minValue=INT 
	 *         maxValue=INT 
	 *         combValue=MathExpression 
	 *         category=[Category|ID]? 
	 *         description=ID?
	 *     )
	 */
	protected void sequence_CombinedAttribute(ISerializationContext context, CombinedAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     (condName=ValidID expression=ConditionTargets op=RelOpTo)
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.CONDITION__COND_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.CONDITION__COND_NAME));
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.CONDITION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.CONDITION__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.CONDITION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.CONDITION__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAccess().getCondNameValidIDParserRuleCall_0_0(), semanticObject.getCondName());
		feeder.accept(grammarAccess.getConditionAccess().getExpressionConditionTargetsParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getConditionAccess().getOpRelOpToParserRuleCall_3_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Consequence returns Consequence
	 *
	 * Constraint:
	 *     (target=ConsequenceRef effect=[Raise|ID])
	 */
	protected void sequence_Consequence(ISerializationContext context, Consequence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.CONSEQUENCE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.CONSEQUENCE__TARGET));
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.CONSEQUENCE__EFFECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.CONSEQUENCE__EFFECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConsequenceAccess().getTargetConsequenceRefEnumRuleCall_0_0(), semanticObject.getTarget());
		feeder.accept(grammarAccess.getConsequenceAccess().getEffectRaiseIDTerminalRuleCall_1_0_1(), semanticObject.getEffect());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeRaiseType returns ConstantBasedRaise
	 *     ConstantBasedRaise returns ConstantBasedRaise
	 *
	 * Constraint:
	 *     result=INT
	 */
	protected void sequence_ConstantBasedRaise(ISerializationContext context, ConstantBasedRaise semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.CONSTANT_BASED_RAISE__RESULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.CONSTANT_BASED_RAISE__RESULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantBasedRaiseAccess().getResultINTTerminalRuleCall_2_0(), semanticObject.getResult());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DecisionTableRef returns DecisionTableRef
	 *
	 * Constraint:
	 *     (decisionTable=[DecisionTable|ID] part=DecisionTablePart)
	 */
	protected void sequence_DecisionTableRef(ISerializationContext context, DecisionTableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.DECISION_TABLE_REF__DECISION_TABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.DECISION_TABLE_REF__DECISION_TABLE));
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.DECISION_TABLE_REF__PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.DECISION_TABLE_REF__PART));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDecisionTableRefAccess().getDecisionTableDecisionTableIDTerminalRuleCall_0_0_1(), semanticObject.getDecisionTable());
		feeder.accept(grammarAccess.getDecisionTableRefAccess().getPartDecisionTablePartEnumRuleCall_2_0(), semanticObject.getPart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns DecisionTable
	 *     DecisionTable returns DecisionTable
	 *
	 * Constraint:
	 *     (name=ID (numberConditionRows=INT numberConsequenceRows=INT)? rows+=Row*)
	 */
	protected void sequence_DecisionTable(ISerializationContext context, DecisionTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CombinationRaiseType returns DeleteCombination
	 *     DeleteCombination returns DeleteCombination
	 *
	 * Constraint:
	 *     delete=Combination
	 */
	protected void sequence_DeleteCombination(ISerializationContext context, DeleteCombination semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.DELETE_COMBINATION__DELETE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.DELETE_COMBINATION__DELETE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeleteCombinationAccess().getDeleteCombinationParserRuleCall_1_0(), semanticObject.getDelete());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeRaiseType returns DiceBasedRaise
	 *     DiceBasedRaise returns DiceBasedRaise
	 *
	 * Constraint:
	 *     (diceToUse=[Dice|ID] result=DiceRef)
	 */
	protected void sequence_DiceBasedRaise(ISerializationContext context, DiceBasedRaise semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.DICE_BASED_RAISE__DICE_TO_USE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.DICE_BASED_RAISE__DICE_TO_USE));
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.DICE_BASED_RAISE__RESULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.DICE_BASED_RAISE__RESULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDiceBasedRaiseAccess().getDiceToUseDiceIDTerminalRuleCall_2_0_1(), semanticObject.getDiceToUse());
		feeder.accept(grammarAccess.getDiceBasedRaiseAccess().getResultDiceRefParserRuleCall_3_0(), semanticObject.getResult());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MathExpression returns DiceRef
	 *     Addition returns DiceRef
	 *     Addition.Addition_1_0 returns DiceRef
	 *     Multiplication returns DiceRef
	 *     Multiplication.Multiplication_1_0 returns DiceRef
	 *     Primary returns DiceRef
	 *     DiceRef returns DiceRef
	 *
	 * Constraint:
	 *     (dice=[Dice|ID] part=DicePart)
	 */
	protected void sequence_DiceRef(ISerializationContext context, DiceRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.DICE_REF__DICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.DICE_REF__DICE));
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.DICE_REF__PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.DICE_REF__PART));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDiceRefAccess().getDiceDiceIDTerminalRuleCall_0_0_1(), semanticObject.getDice());
		feeder.accept(grammarAccess.getDiceRefAccess().getPartDicePartEnumRuleCall_2_0(), semanticObject.getPart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Dice
	 *     Dice returns Dice
	 *
	 * Constraint:
	 *     (name=ID maxValue=INT)
	 */
	protected void sequence_Dice(ISerializationContext context, Dice semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.ENTITY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.ENTITY__NAME));
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.DICE__MAX_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.DICE__MAX_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDiceAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDiceAccess().getMaxValueINTTerminalRuleCall_3_0(), semanticObject.getMaxValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Domainmodel returns Domainmodel
	 *
	 * Constraint:
	 *     (importSection=XImportSection? name=QualifiedName elements+=Entity*)
	 */
	protected void sequence_Domainmodel(ISerializationContext context, Domainmodel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InitAttribute returns InitAttribute
	 *
	 * Constraint:
	 *     (initValue=INT | diceRef=DiceRef)
	 */
	protected void sequence_InitAttribute(ISerializationContext context, InitAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InitialAttributeDecision returns InitialAttributeDecision
	 *
	 * Constraint:
	 *     type=InitAttribute
	 */
	protected void sequence_InitialAttributeDecision(ISerializationContext context, InitialAttributeDecision semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.INITIAL_ATTRIBUTE_DECISION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.INITIAL_ATTRIBUTE_DECISION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitialAttributeDecisionAccess().getTypeInitAttributeParserRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MathExpression returns Multiplication
	 *     Addition returns Multiplication
	 *     Addition.Addition_1_0 returns Multiplication
	 *     Multiplication returns Multiplication
	 *     Multiplication.Multiplication_1_0 returns Multiplication
	 *     Primary returns Multiplication
	 *
	 * Constraint:
	 *     (left=Multiplication_Multiplication_1_0 (op='*' | op='/') right=Primary)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Multiplication semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (name=ValidID (params+=FullJvmFormalParameter params+=FullJvmFormalParameter*)? type=JvmTypeReference body=XBlockExpression)
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (attrValue=[Attribute|ID] | combAttrValue=[CombinedAttribute|ID] | combValue=[Combination|ID])
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RowRef returns RowRef
	 *
	 * Constraint:
	 *     (row=[Row|ID] part=RowPart)
	 */
	protected void sequence_RowRef(ISerializationContext context, RowRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.ROW_REF__ROW) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.ROW_REF__ROW));
			if (transientValues.isValueTransient(semanticObject, CreatePackage.Literals.ROW_REF__PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CreatePackage.Literals.ROW_REF__PART));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRowRefAccess().getRowRowIDTerminalRuleCall_0_0_1(), semanticObject.getRow());
		feeder.accept(grammarAccess.getRowRefAccess().getPartRowPartEnumRuleCall_2_0(), semanticObject.getPart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Row returns Row
	 *
	 * Constraint:
	 *     (index=INT conditions+=Condition conditions+=Condition* consequences+=Consequence consequences+=Consequence*)
	 */
	protected void sequence_Row(ISerializationContext context, Row semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
